% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrixEpistasis.R
\name{matrixEpistasis}
\alias{matrixEpistasis}
\title{matrixEpistasis}
\usage{
matrixEpistasis(snpA, snpB, trait, covariate = NULL)
}
\arguments{
\item{snpA}{a matrix of numeric values in size of sample*snp representing the 1st group of SNPs, where the column names are the snp_ids}

\item{snpB}{a matrix of numeric values in size of sample*snp representing the 2nd group of SNPs, where the column names are the snp_ids}

\item{trait}{a vector of numeric values representing the quantitative trait}

\item{covariate}{a matrix of numeric values in size of sample*covariate, by default, NULL}
}
\value{
A list containing the follow components:
\itemize{
 \item {r} a matrix of numeric values representing the partial correlation coefficients between snpA*snpB and traits conditioned on snpA, snpB and covariates
 \item {df} an integer value representing the degree of freedom
}
}
\description{
matrixEpistasis uses large matrix operation to perform the exhaustive epistasis scan for quantitative traits with covariate adjustment
}
\examples{
# randomly generate a SNP matrix
snp <- sapply(1:100,function(i) rnorm(1000) )
# assign names to SNPs
colnames(snp) <- paste0('snp',1:100)
snpA = snp
snpB = snp

# radnomly generate a quantitative trait by simulating the relationship between SNPs and traits
trait <- snp \%*\% rnorm(100)

# use the top 5 PCs as the covariates 
covariate <- prcomp(snp)$x[,1:5]

# run matrixEpistasis with covariates adjustment
res <- matrixEpistasis( snpA=snpA, snpB=snpB, trait=trait, covariate = covariate )
r <- res$r
df <- res$df

# run matrixEpistasis function with covariates adjustment
res <- matrixEpistasis( snpA=snpA, snpB=snpB, trait=trait, covariate = covariate )

# res is a list comprising two components: r and df. res$r is the matrix of partial correlation coefficients between snp interaction (snpA*snpB) and trait with additive effects (snpA and snpB) and covariates adjusted, and res$df is the degree of freedom for the partial correlation.
names(res)
r = res$r 
df = res$df

# based on the degree of freedom, run matrixPval function to calculate p values for all partial correlation coefficients. The result is a matrix of p-values for epistasis of all snp interactions.
p <- matrixPval( r , df )

# alternatively, users can calculate p-values only for those entries with p vlaues less than a given threshold, say 1e-2, shown as follows: 
# use p2c to covert p value threshold 1e-5 to the corresponding partial correlation coefficient
corrThreshold <- p2c( pval=1e-2 , df )

# extract the index for those significant ones
index <- which( abs(r)>corrThreshold , arr.ind=TRUE )

# get the SNP names
snp1 <- colnames(snpA)[ index[,1] ]
snp2 <- colnames(snpB)[ index[,2] ]

# use matrixPval function to calculate p values for only those of interest
pvalue <- matrixPval( r[index] , df  )

# build the data frame
sig_res <- data.frame( snp1 , snp2 , pvalue )
head(sig_res)

}
\references{

}
\seealso{
\code{\link{p2c}}; \code{\link{matrixPval}}; \code{\link{smoothQQplot}}
}
\author{
Shijia Zhu, \email{shijia.zhu@mssm.edu}
}
